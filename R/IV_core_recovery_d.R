#' recovery_d
#'
#' @description
#' This function applies `fit_p` to each fake dataset in the list generated 
#' by `simulate_l`. The results can be used for parameter recovery and 
#' model recovery, helping evaluate the consistency and validity of the 
#' reinforcement learning model.
#' 
#' For more information, please refer to the GitHub repository:
#' https://github.com/yuki-961004/binaryRL
#'
#' @param list [list] a list generated by function `simulate_l`
#' 
#' @param obj_func [function] a function with only ONE argument `params`. 
#'  Additionally, it is important to note that the data needs to be retrieved 
#'  from parent.frame() and the results passed back to parent.frame(). 
#'  This function returns the log likelihood (logL).
#' 
#' @param model_name the name of your modal
#' 
#' @param initial [vector] Initial values for the free parameters. 
#'  These need to be set only when using L-BFGS-B. Other algorithms 
#'  automatically generate initial values.
#' 
#' @param lower [vector] lower bounds of free parameters
#' 
#' @param upper [vector] upper bounds of free parameters
#' 
#' @param seed [integer] random seed. This ensures that the results are 
#'  reproducible and remain the same each time the function is run. 
#'  default: `seed = 123` 
#'  
#' @param iteration [integer] the number of iteration
#' 
#' @param algorithm [character] Choose a algorithm package from 
#'  `L-BFGS-B`, `GA`, `GenSA`, `DEoptim`
#'
#' @return a data frame for parameter recovery and model recovery
#' @export
#'
recovery_d <- function(
    list,
    obj_func,
    model_name,
    initial,
    lower,
    upper,
    algorithm,
    iteration = 10,
    seed = 123
){
  # 创建一个空数据集, 用于存放结果
  recovery <- data.frame(
    model = rep(model_name, length(list)),
    ACC = NA,
    LL = NA,
    AIC = NA,
    BIC = NA
  )
  
  # 增加放置输入参数的列
  n_input_params <- length(list[[1]]$input)
  
  for (i in 1:n_input_params) {
    recovery[, i + 5] <- NA
    names(recovery)[i + 5] <- paste0("input_param_", i)
  }
  # 增加放置输出参数的列
  n_output_params <- length(lower)
  
  for (i in 1:n_output_params) {
    recovery[, i + 5 + n_input_params] <- NA
    names(recovery)[i + 5 + n_input_params] <- paste0("output_param_", i)
  }
  
  # 用解题模型求解参数
  for (i in 1:length(list)){
    data <- list[[i]][[1]]
    
    binaryRL_res <- binaryRL::fit_p(
      data = data,
      obj_func = obj_func,
      algorithm = algorithm,
      initial = initial,
      lower = lower,
      upper = upper,
      iteration = iteration,
      seed = seed
    )
    
    # 每解完一次题就存一次结果
    recovery[i, 2] <- binaryRL_res$acc
    recovery[i, 3] <- binaryRL_res$ll
    recovery[i, 4] <- binaryRL_res$aic
    recovery[i, 5] <- binaryRL_res$bic
    
    for (j in 1:n_input_params) {
      recovery[i, j + 5] <- list[[i]]$input[j]
    }
    
    # 增加放置输出参数的列
    for (j in 1:n_output_params) {
      recovery[i, j + 5 + n_input_params] <- binaryRL_res$output[j]
    }
  }
  
  return(recovery)
}
