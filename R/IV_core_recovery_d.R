#' recovery_d
#'
#' @param list a list generated by function `simulate_l`
#' @param obj_func object function
#' @param model_name model name
#' @param initial initial value for searching parameters, only needed in stats
#' @param lower lower bounds of parameters
#' @param upper upper bounds of parameters
#' @param iteration iteration
#' @param seed A numeric value to set the random seed. 
#' This ensures that the results are reproducible and remain the same each time the function is run.
#' Provide the value as a number. 
#' default: `seed = 123` 
#' @param algorithm Choose a algorithm pacakge from `L-BFGS-B`, `GA`, `GenSA`, `DEoptim`
#'
#' @return data frame for parameter recovery and model recovery
#' @export
#'
recovery_d <- function(
    list,
    obj_func,
    model_name,
    initial,
    lower,
    upper,
    algorithm,
    iteration = 10,
    seed = 123
){
  # 创建一个空数据集, 用于存放结果
  recovery <- data.frame(
    model = rep(model_name, length(list)),
    ACC = NA,
    LL = NA,
    AIC = NA,
    BIC = NA
  )
  
  # 增加放置输入参数的列
  n_input_params <- length(list[[1]]$input)
  
  for (i in 1:n_input_params) {
    recovery[, i + 5] <- NA
    names(recovery)[i + 5] <- paste0("input_param_", i)
  }
  # 增加放置输出参数的列
  n_output_params <- length(lower)
  
  for (i in 1:n_output_params) {
    recovery[, i + 5 + n_input_params] <- NA
    names(recovery)[i + 5 + n_input_params] <- paste0("output_param_", i)
  }
  
  # 用解题模型求解参数
  for (i in 1:length(list)){
    data <<- list[[i]][[1]]
    
    binaryRL_res <- binaryRL::fit_p(
      data = data,
      obj_func = obj_func,
      algorithm = algorithm,
      initial = initial,
      lower = lower,
      upper = upper,
      iteration = iteration,
      seed = seed
    )
    
    # 每解完一次题就存一次结果
    recovery[i, 2] <- binaryRL_res$acc
    recovery[i, 3] <- binaryRL_res$ll
    recovery[i, 4] <- binaryRL_res$aic
    recovery[i, 5] <- binaryRL_res$bic
    
    for (j in 1:n_input_params) {
      recovery[i, j + 5] <- list[[i]]$input[j]
    }
    
    # 增加放置输出参数的列
    for (j in 1:n_output_params) {
      recovery[i, j + 5 + n_input_params] <- binaryRL_res$output[j]
    }
  }
  
  return(recovery)
}