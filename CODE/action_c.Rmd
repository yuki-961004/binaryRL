---
title: "Untitled"
author: "YuKi"
date: "2024-08-05"
output: html_document
---
```{r}
library(dplyr)
```

```{r}
step1 <- loop_update_v(
  data = raw, 
  # 被试序号列
  sub = "Subject",
  # 被试选择列
  choose = "Choose",
  # 价值更新的时间线, 基于的列
  time_line = c("Block", "Trial"),
  # 初始值
  initial_value = 0,
  # parameters
  params = c(0.5, 0.6, 0.7, 0.8, 0.9, 0.99, 50, 20),
  # 价值函数选用示例函数
  eta_func = example_function
) 
```

```{r}
ex_func_prob <- function(
  L_value = df_wider$L_value[i],
  R_value = df_wider$R_value[i],
  tau = 1,
  LR
  ){
  if (!(LR %in% c("L", "R"))) {
    stop("Prob of L or R")
  }
  else if (LR == "L") {
    prob <- 1 / (1 + exp(-(L_value - R_value) * tau))
  }
  else if (LR == "R") {
    prob <- 1 / (1 + exp(-(R_value - L_value) * tau))
  }
  else {
    prob <- "ERROR"
  }
  return(prob)
}

```

```{r}
ex_func_prob(
  L_value = 22,
  R_value = 20,
  tau = 1,
  LR = "L"
)

ex_func_prob(
  L_value = 22,
  R_value = 20,
  tau = 1,
  LR = "R"
)
```


```{r}
seed = 123
softmax = TRUE
# 左右选项
L_choice = "DL"
R_choice = "DR"
# 初始值
initial_value = 0
# update_v数据集
df_raw <- step1
# 长转宽
df_wider <- step1 %>%
  dplyr::mutate(
    names = Choose,
    values = V_value
  ) %>%
  tidyr::pivot_wider(
    names_from = "names",
    values_from = "values"
  )

# 长转宽前后不同的列, 也就是Choose列
wide_columns1 <- setdiff(x = names(df_raw), y = "ID")
wide_columns2 <- setdiff(x = names(df_wider), y = "ID")
choose_col <- setdiff(wide_columns2, wide_columns1)

# 初始化 L_value 和 R_value 列
df_wider$L_value <- NA
df_wider$R_value <- NA
df_wider$L_prob <- NA
df_wider$R_prob <- NA
df_wider$Sub_Choose <- df_wider$Choose
df_wider$Rob_Choose <- NA
df_wider$L_dir <- NA
df_wider$R_dir <- NA
df_wider$L_logl <- NA
df_wider$R_logl <- NA
df_wider$ACC <- NA

# 处理选择列和更新 L_value 和 R_value
for (i in 1:nrow(df_wider)) {
  for (col in choose_col) {
    if (i == 1) {
      df_wider[i, col] <- initial_value
    } else if (is.na(df_wider[i, col])) {
      df_wider[i, col] <- df_wider[i - 1, col]
    }
  }
  
  # 更新 L_value 和 R_value 列
  L_name <- df_wider[[L_choice]][i]
  R_name <- df_wider[[R_choice]][i]
  df_wider$L_value[i] <- df_wider[[L_name]][i]
  df_wider$R_value[i] <- df_wider[[R_name]][i]
  df_wider$L_prob[i] <- round(ex_func_prob(LR = "L", tau = 1), 2)
  df_wider$R_prob[i] <- round(ex_func_prob(LR = "R", tau = 1), 2)
   
  if (!(softmax %in% c(TRUE, FALSE))) {
    stop("softmax")
  }
  else if (softmax == TRUE) {
    # 基于刚刚的概率, 随机选一个. 而不是谁大选谁
    set.seed(seed = seed)
    df_wider$Rob_Choose[i] <- sample(
      c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), size = 1, 
      prob = c(df_wider$L_prob[i], df_wider$R_prob[i])
    ) 
  } 
  else if (softmax == FALSE) {
    # 如果左边大选左边
    if (df_wider$L_value[i] > df_wider$R_value[i]) {
      df_wider$Rob_Choose[i] <- df_wider[[L_choice]][i]
    } 
    # 如果右边大选右边
    else if (df_wider$L_value[i] < df_wider$R_value[i]) {
      df_wider$Rob_Choose[i] <- df_wider[[R_choice]][i]
    } 
    # 一样大随机选一个(说明是DS情况)
    else if (df_wider$L_value[i] == df_wider$R_value[i]) {
      df_wider$Rob_Choose[i] <- sample(
        c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), size = 1
      )
    } 
    # 除此以外, 则说明有问题
    else {
      df_wider$Rob_Choose[i] <- "ERROR"
    }
  }
  else {
    print("ERROR softmax")
  }
  
  if (df_wider$Sub_Choose[i] == df_wider[[L_choice]][i]) {
    df_wider$L_dir[i] <- 1
    df_wider$R_dir[i] <- 0
  } 
  else if (df_wider$Sub_Choose[i] == df_wider[[R_choice]][i]){
    df_wider$L_dir[i] <- 0
    df_wider$R_dir[i] <- 1
  }
  else {
    print("L/R_dir ERROR")
  }
  
  df_wider$L_logl[i] <- round(df_wider$L_dir[i] * log(df_wider$L_prob[i] + 1e-10), 2)
  df_wider$R_logl[i] <- round(df_wider$R_dir[i] * log(df_wider$R_prob[i] + 1e-10), 2)
  
  if (df_wider$Sub_Choose[i] == df_wider$Rob_Choose[i]) {
    df_wider$ACC[i] <- 1
  }
  else {
    df_wider$ACC[i] <- 0
  }
}
```

```{r}
rl_action_c <- function(
  # update_v数据集
  data,
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  # 初始值
  initial_value = 0,
  seed = 123,
  softmax = TRUE,
  tau = 1,
  prob_func = ex_func_prob
){
  # 长转宽
  df_wider <- data %>%
    dplyr::mutate(
      names = Choose,
      values = V_value
    ) %>%
    tidyr::pivot_wider(
      names_from = "names",
      values_from = "values"
    )
  
  # 长转宽前后不同的列, 也就是Choose列
  wide_columns1 <- setdiff(x = names(data), y = "ID")
  wide_columns2 <- setdiff(x = names(df_wider), y = "ID")
  choose_col <- setdiff(wide_columns2, wide_columns1)
  
  # 初始化 L_value 和 R_value 列
  df_wider$L_value <- NA
  df_wider$R_value <- NA
  df_wider$L_prob <- NA
  df_wider$R_prob <- NA
  df_wider$Sub_Choose <- df_wider$Choose
  df_wider$Rob_Choose <- NA
  df_wider$L_dir <- NA
  df_wider$R_dir <- NA
  df_wider$L_logl <- NA
  df_wider$R_logl <- NA
  df_wider$ACC <- NA
  
  # 循环生成每一列
  for (i in 1:nrow(df_wider)) {
    # 基础是生成逐行更新的 L_value 和 R_value
    for (col in choose_col) {
      if (i == 1) {
        df_wider[i, col] <- initial_value
      } else if (is.na(df_wider[i, col])) {
        df_wider[i, col] <- df_wider[i - 1, col]
      }
    }
    
    # 基于L_choice, R_choice, 知道哪两列是选项列. 存入左右名字
    L_name <- df_wider[[L_choice]][i]
    R_name <- df_wider[[R_choice]][i]
    # 基于左右名字, 寻找左右选项此时价值
    df_wider$L_value[i] <- df_wider[[L_name]][i]
    df_wider$R_value[i] <- df_wider[[R_name]][i]
    ############################ [ CORE CODE ] #################################
    # 基于prob函数计算选择左边和右边的概率
    df_wider$L_prob[i] <- round(
      x = prob_func(
        L_value = df_wider$L_value[i],
        R_value = df_wider$R_value[i],
        LR = "L", 
        tau = tau
      ),
      digits = 2
    )
    df_wider$R_prob[i] <- round(
      x = prob_func(
        L_value = df_wider$L_value[i],
        R_value = df_wider$R_value[i],
        LR = "R", 
        tau = tau
      ),
      digits = 2
    )
    ############################################################################
    
    # 如果是softmax就基于概率随机选
    if (softmax == TRUE) {
      # 基于刚刚的概率, 随机选一个. 而不是谁大选谁
      set.seed(seed = seed)
      df_wider$Rob_Choose[i] <- sample(
        c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), size = 1, 
        prob = c(df_wider$L_prob[i], df_wider$R_prob[i])
      ) 
    } 
    # 如果不基于softmax, 就是谁大选谁
    else if (softmax == FALSE) {
      # 如果左边大选左边
      if (df_wider$L_value[i] > df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- df_wider[[L_choice]][i]
      } 
      # 如果右边大选右边
      else if (df_wider$L_value[i] < df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- df_wider[[R_choice]][i]
      } 
      # 一样大随机选一个(说明是DS情况)
      else if (df_wider$L_value[i] == df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- sample(
          c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), size = 1
        )
      } 
      # 除此以外, 则说明有问题
      else {
        print("ERROR softmax")
      }
    }
    else {
      print("softmax TRUE or FALSE?")
    }
    
    # 如果选项即等于左也等于右, 则说明此时只有一个选项
    if (df_wider$Sub_Choose[i] == L_name & df_wider$Sub_Choose[i] == R_name) {
      df_wider$L_dir[i] <- 0
      df_wider$R_dir[i] <- 0
    } 
    # 选了左
    else if (df_wider$Sub_Choose[i] == L_name & df_wider$Sub_Choose[i] != R_name){
      df_wider$L_dir[i] <- 1
      df_wider$R_dir[i] <- 0
    }
    # 选了右
    else if (df_wider$Sub_Choose[i] != L_name & df_wider$Sub_Choose[i] == R_name){
      df_wider$L_dir[i] <- 0
      df_wider$R_dir[i] <- 1
    }
    else {
      print("L/R_dir ERROR")
    }
    # 基于得到的被试选项与强化学习估计的选择概率, 计算似然值
    df_wider$L_logl[i] <- round(df_wider$L_dir[i] * log(df_wider$L_prob[i] + 1e-10), 2)
    df_wider$R_logl[i] <- round(df_wider$R_dir[i] * log(df_wider$R_prob[i] + 1e-10), 2)
    # 如果被试和强化学习选择一致, 则是1, 不一致则是0
    if (df_wider$Sub_Choose[i] == df_wider$Rob_Choose[i]) {
      df_wider$ACC[i] <- 1
    }
    else {
      df_wider$ACC[i] <- 0
    }
  }
  
  return(df_wider)
}
```

```{r}
test <- action_c(data = step1 %>% dplyr::filter(Subject == 1))
```

```{r loop_evaluate}
loop_action_c <- function(
  # update_v数据集
  data,
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  sub = "Subject",
  # 初始值
  sub_id,
  initial_value = 0,
  seed = 123,
  softmax = TRUE,
  tau = 1,
  prob_func = ex_func_prob
  ) {
  
  df_split <- base::split(x = data, f = data[[sub]])
  df_res <- list()
  
  for (i in sub_id) {
    df_subject <- df_split[[i]]
    df_res[[i]] <- rl_action_c(
      data = df_subject, 
      # 左右选项
      L_choice = L_choice,
      R_choice = R_choice,
      # 初始值
      initial_value = initial_value,
      seed = seed,
      softmax = softmax,
      tau = tau,
      prob_func = prob_func
    )
  }
  
  res <- dplyr::bind_rows(df_res) %>%
    dplyr::arrange(Subject, Block, Trial)
  
  return(res)
}
```

```{r}
step2 <- loop_action_c(
  # update_v数据集
  data = step1,
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  sub = "Subject",
  # 初始值
  sub_id = 1,
  initial_value = 0,
  seed = 123,
  softmax = FALSE,
  tau = 1,
  prob_func = ex_func_prob  
)
```

