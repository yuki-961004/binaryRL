---
title: "Untitled"
author: "YuKi"
date: "2024-08-02"
output: html_document
---
```{r}
library(dplyr)
```

```{r}
raw <- read.csv("../DATA/df1_Delot.csv") %>%
  dplyr::mutate(
    DL = case_when(
      Frame == "Single" ~ DS,
      TRUE ~ DL
    ),
    DR = case_when(
      Frame == "Single" ~ DS,
      TRUE ~ DR
    ),
  ) %>%
  dplyr::select(-DS, -NetWorth)
```

```{r}
ex_func_eta <- function(
  # 此时心中对该刺激的的value
  value, 
  # 选择后看到的reward
  reward, 
  # 第几次看到这个刺激
  occurrence, 
  # 使用的参数
  params
################################# [function start] #############################
){
  if (is.na(reward)) {
    stop()
  }
################################### [ RSTD ] ###################################
  else if (reward > value) {
    eta <- params[1]
  } 
  else if (reward <= value) {
    eta <- params[2]
  }
################################### [ RSTD ] ###################################
  else {
    eta <- "ERROR" # 检查错误
  }
  return(eta)
}

```

```{r}
test <- ex_func_eta(
  reward = 40,
  value = 0,
  occurrence = 1,
  params = c(0.3, 0.7)
)
```

```{r}
rl_update_v <- function(
  # 输入data frame
  data,
  # 价值更新的时间线, 基于的列
  time_line = c("Block", "Trial"),
  # 被试心中价值初始值
  initial_value = 0,
  # parameters
  params = c(0.3, 0.7),
  # 价值函数选用示例函数
  eta_func = ex_func_eta
################################# [function start] #############################
){
################################## [Arrange] ###################################
  # 基于time_line这个向量, 录入排序向量
  order_vector <- lapply(time_line, function(col) data[[col]])
  
  # 基于排序向量对输入数据集进行排序
  temp_data <- data[do.call(order, order_vector), ]
  
############################### [Add Null row] #################################
  # 生成一个与输入数据集相同的单行数据集. 用于存放初始值
  empty_row <- as.data.frame(matrix(ncol = ncol(data), nrow = 1))
  colnames(empty_row) <- colnames(data)
  
  # 在第一行插入一个空行
  temp_data <- rbind(empty_row, temp_data)
  temp_data$Time_Line <- seq(from = 0, to = nrow(data))
  
############################# [ update row by row] #############################
  # 添加空列
  temp_data$V_value <- NA
  temp_data$eta <- NA
  temp_data$V_update <- NA
  
  # 设置初始值
  temp_data$V_value[1] <- initial_value
  temp_data$V_update[1] <- initial_value
  
  # 逐行更新Value
  for (i in 2:nrow(temp_data)) {
    # value是上一行的update
    temp_data$V_value[i] <- temp_data$V_update[i - 1]
    # 使用eta_func选择此时对应的eta
    temp_data$eta[i] <- eta_func(
      value = temp_data$V_value[i],
      reward = temp_data$Reward[i],
      occurrence = temp_data$Time_Line[i],
      params = params
    )
    # 计算此次update的值
    temp_data$V_update[i] <- temp_data$V_value[i] + 
      temp_data$eta[i] * (temp_data$Reward[i] - temp_data$V_value[i])
  }
  
############################## [delete first row] ############################## 
  # 删除第一行赋予的初始值
  res_data <- temp_data[-1, ]
  # 对于V取两位小数
  res_data$V_value <- round(res_data$V_value, 2)
  res_data$V_update <- round(res_data$V_update, 2)
  # 返回结果
  return(res_data)
}
```

```{r}
test <- rl_update_v(
  data = raw %>% filter(Subject == 1 & Choose == "Green"), 
  time_line = c("Block", "Trial"),
  initial_value = 0,
  params = c(0.3, 0.7),
  eta_func = ex_func_eta
)
```

```{r loop_update}
loop_update_v <- function(
  data,
  # 被试序号列, 列名
  sub = "Subject",
  # 被试选择列
  choose = "Choose",
  # 价值更新的时间线, 基于的列
  time_line = c("Block", "Trial"),
  # 被试心中价值初始值
  initial_value = 0,
  # 要处理多少个被试. 由于估计时候是对被试分别进行, 所以这里也是被试序号
  n,
  # parameters
  params = c(0.3, 0.7),
  # 价值函数选用示例函数
  eta_func = ex_func_eta
################################# [function start] #############################
){
################################# [split sub data] #############################
  # 按照[被试序号列][sub]分裂原始数据
  df_split <- base::split(x = data, f = data[[sub]])
  # 新建空list, 每个被试的结果存入该list的一个元素中
  df_res <- list()
  
  # 循环的每次针对一个被试
  for (i in n) {
    # 被试i的数据
    df_subject <- df_split[[i]]
    # 按照选择的不同进行分裂
    df_choose <- split(x = df_subject, f = df_subject[[choose]])
############################# [res for each stimulate] #########################
    # 每种选择的结果存入该list的一个元素中
    df_update <- list()
################################ [ CORE CODE ] #################################
    # 对每种choose运行update_v
    df_update <- purrr::map(
      # list对象, 每个元素执行一次function
      .x = df_choose, 
      # function是update_v
      .f = rl_update_v,
      # 价值更新的时间线, 基于的列
      time_line = time_line,
      # 初始值
      initial_value = initial_value,
      # parameters
      params = params,
      # 价值函数选用示例函数
      eta_func = eta_func
    )
################################ [ CORE CODE ] #################################
    # 把所有choose类型的结果合并, 成为一个被试的结果
    df_res[[i]] <- dplyr::bind_rows(df_update)
  }

################################### [result] ###################################
  # 把所有被试的结果合并, 成为总结果
  temp_res <- dplyr::bind_rows(df_res) 
  # 此时排序基于sub和time_line
  order_var <- c(sub, time_line)
  # 基于time_line这个向量, 录入排序向量
  order_vector <- lapply(order_var, function(col) temp_res[[col]])
  # 基于排序向量对输入数据集进行排序
  res <- temp_res[do.call(order, order_vector), ]
  
  return(res)
}
```

```{r}
test <- loop_update_v(
  data = raw, 
  sub = "Subject",
  choose = "Choose",
  time_line = c("Block", "Trial"),
  initial_value = 0,
  n = 1:41,
  params = c(0.3, 0.7),
  eta_func = ex_func_eta
)
```



