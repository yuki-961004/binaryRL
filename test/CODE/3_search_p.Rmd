---
title: "search_p"
author: "YuKi"
date: "2024-08-08"
output: html_document
---
```{r}
library(dplyr)
library(GA)
#install.packages("../../../yukiRL_0.0.3.tar.gz")
library(yukiRL)
```

```{r}
print(yukiRL::ex_func_eta)
print(yukiRL::ex_func_prob)
```


```{r}
raw <- read.csv("../DATA/df1_Delot.csv") %>%
  dplyr::mutate(
    DL = case_when(
      Frame == "Single" ~ DS,
      TRUE ~ DL
    ),
    DR = case_when(
      Frame == "Single" ~ DS,
      TRUE ~ DR
    ),
  ) %>%
  dplyr::select(-DS, -NetWorth)
```

```{r}
data <- raw

# 第一步, 生成Value
step1 <- yukiRL::loop_update_v(
  data = data, 
  # 被试序号列
  sub = "Subject",
  # 被试选择列
  choose = "Choose",
  # 价值更新的时间线, 基于的列
  time_line = c("Block", "Trial"),
  # 被试id
  n = 1,
  # 初始值
  initial_value = 0,
  # parameters
  params = c(0.3, 0.7),
  # 价值函数选用示例函数
  eta_func = yukiRL::ex_func_eta
) 

# 第二步, 基于左右的Value, 计算选择左右的概率
step2 <- yukiRL::loop_action_c(
  # update_v数据集
  data = step1,
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  sub = "Subject",
  # step1中的几个被试, 如果step1只有一个, 这里就填1
  n = 1,
  initial_value = 0,
  seed = 123,
  softmax = FALSE,
  tau = 1,
  params = NA,
  prob_func = yukiRL::ex_func_prob  
)
```


```{r}
obj_func <- function(params){
  # 全局变量里需要有原始数据集
  data <- raw
  
  # 第一步, 生成Value
  step1 <- yukiRL::loop_update_v(
    data = data, 
    # 被试序号列
    sub = "Subject",
    # 被试选择列
    choose = "Choose",
    # 价值更新的时间线, 基于的列
    time_line = c("Block", "Trial"),
    # 被试id
    n = 1,
    # 初始值
    initial_value = 0,
    # parameters
    params = c(params[1], params[2]),
    # 价值函数选用示例函数
    eta_func = yukiRL::ex_func_eta
  ) 
  
  # 第二步, 基于左右的Value, 计算选择左右的概率
  step2 <- yukiRL::loop_action_c(
    # update_v数据集
    data = step1,
    # 左右选项
    L_choice = "DL",
    R_choice = "DR",
    sub = "Subject",
    # step1中的几个被试, 如果step1只有一个, 这里就填1
    n = 1,
    initial_value = 0,
    seed = 123,
    softmax = FALSE,
    tau = params[3],
    params = NA,
    prob_func = yukiRL::ex_func_prob  
  )
  
  mean_ACC <- round(mean(step2$ACC), 4) * 100
  cat("Mean Accuracy:", mean_ACC, "%", "\n")
  
  Log_Likelihood <- sum(step2$L_logl) + sum(step2$R_logl)
  return(Log_Likelihood)
}
```

```{r}
# 设置并行计算环境
cl <- parallel::makeCluster(parallel::detectCores() - 2)
doParallel::registerDoParallel(cores = cl)

# 使用遗传算法搜寻最佳参数
ga_result <- GA::ga(
  type = "real-valued",
  fitness = function(x) obj_func(x),
  lower = c(0, 0, 0),
  upper = c(2, 2, 2),
  popSize = 50,        # 初始种群大小
  maxiter = 5,         # 最大迭代次数
  run = 20,            # 多少次不改进则停止
  parallel = TRUE,          
  seed = 123                
)

# 取消并行计算环境
parallel::stopCluster(cl)
foreach::registerDoSEQ()
rm(cl)
```

```{r}
output <- function(
    ga_result = ga_result, 
    obj_func = obj_func,
    n_trials,
    params_name
){
  n_params <- ncol(ga_result@solution)
  n_trials <- n_trials
  Log_Likelihood <- ga_result@fitnessValue
  
  params <- as.vector(ga_result@solution)
  acc <- capture.output(obj_func(params = params))[1]
  
  cat("Number of Parameters:", n_params, "\n")
  cat("Number of Trials:", n_trials, "\n", "\n")
  
  cat(acc, "\n")
  cat("Log-Likelihood:", Log_Likelihood, "\n")
  cat("AIC:", 2 * n_params - 2 * Log_Likelihood, "\n")
  cat("BIC:", n_params * log(n_trials) - 2 * Log_Likelihood, "\n", "\n")
  
  for (i in 1:ncol(ga_result@solution)) {
    cat(params_name[i], ga_result@solution[1,i], "\n")
  }
  
}
```


```{r}
yukiRL::output(
  ga_result = ga_result, 
  obj_func = obj_func,
  n_trials = 288,
  params_name = c("η+", "η-", "τ")
)
```

