---
title: "Untitled"
author: "YuKi"
date: "2024-08-05"
output: html_document
---
```{r}
library(dplyr)
```

```{r}
step1 <- loop_update_v(
  data = raw, 
  sub = "Subject",
  choose = "Choose",
  time_line = c("Block", "Trial"),
  initial_value = 0,
  n = 1:41,
  params = c(0.3, 0.7),
  eta_func = ex_func_eta
)
```

```{r}
ex_func_prob <- function(
  # 左边选项的价值
  L_value,
  # 右边选项的价值
  R_value,
  # softmax固有参数, 默认为1
  tau = 1,
  # 其他你想使用的参数, 默认没有
  params = NA,
  # 此时计算的是选左概率还是选右概率
  LR
){
  if (!(LR %in% c("L", "R"))) {
    stop("LR = 'L' or 'R'")
  }
################################# [ softmax ] ##################################
  else if (LR == "L") {
    prob <- 1 / (1 + exp(-(L_value - R_value) * tau))
  }
  else if (LR == "R") {
    prob <- 1 / (1 + exp(-(R_value - L_value) * tau))
  }
################################# [ softmax ] ##################################
  else {
    prob <- "ERROR"
  }
  return(prob)
}

```

```{r}
ex_func_prob(
  L_value = 22,
  R_value = 20,
  tau = 1,
  params = NA,
  LR = "L"
)

ex_func_prob(
  L_value = 22,
  R_value = 20,
  tau = 1,
  params = NA,
  LR = "R"
)
```

```{r}
rl_action_c <- function(
  # update_v数据集
  data,
  # 左右选项是什么, 对应的列名
  L_choice = "DL",
  R_choice = "DR",
  # 被试选择列的列名
  choose = "Choose",
  # 被试心中价值列的列名
  value = "V_value",
  # 被试心中价值初始值
  initial_value = 0,
  # softmax选择时的随机种子
  seed = 123,
  # 是否使用softmax, 还是说value谁大选谁
  softmax = TRUE,
  # softmax的固有参数, 默认为1
  tau = 1,
  # 如果你的softmax含有别的参数, 就放在这里
  params = NA,
  # 示例softmax函数
  prob_func = ex_func_prob
################################# [function start] #############################
){
  # 为了保证choose和value在长转宽中这两列不消失. 所以复制一次
  data$names <- data[[choose]]
  data$values <- data[[value]]
  # 长转宽, 这样每个刺激类型, 就变成了一列
  df_wider <- data %>%
    tidyr::pivot_wider(
      names_from = "names",
      values_from = "values"
    )
  
  # 长转宽前后不同的列, 每个刺激类型, 就是新增的列
  wide_columns1 <- setdiff(x = names(data), y = "ID")
  wide_columns2 <- setdiff(x = names(df_wider), y = "ID")
  choose_col <- setdiff(wide_columns2, wide_columns1)
  
############################### [Initialization] ###############################
  # 左右选项对应的价值
  df_wider$L_value <- NA
  df_wider$R_value <- NA
  # 基于左右选项价值算出来的选左或右的概率
  df_wider$L_prob <- NA
  df_wider$R_prob <- NA
  # 被试选了什么[刺激]
  df_wider$Sub_Choose <- df_wider$Choose
  # 机器人想选什么[刺激]
  df_wider$Rob_Choose <- NA
  # 被试选的是左还是右
  df_wider$L_dir <- NA
  df_wider$R_dir <- NA
  # 似然值: 机器人选[左/右]的概率 * 被试选了[左/右]
  df_wider$L_logl <- NA
  df_wider$R_logl <- NA
  # 被试选的和机器人选的是否一致
  df_wider$ACC <- NA

################################ [Loop Update] #################################
  # 对宽数据逐行赋予值
  for (i in 1:nrow(df_wider)) {
    # 首先对刺激种类列[choose_col]进行操作
    for (col in choose_col) {
      # 如果现在是刺激种类列[choose_col]的第一行, 则给他们赋予初始值
      if (i == 1) {
        df_wider[i, col] <- initial_value
      } 
      # 如果不是刺激种类列[choose_col]第一行, 且是NA, 那么说明此次没有选择它
      else if (is.na(df_wider[i, col])) {
      # 它的值等于上次更新它时的数值. 也就是上一行的值
        df_wider[i, col] <- df_wider[i - 1, col]
      }
    }
    
    # 第i行中, 左选项和右选项叫什么
    L_name <- df_wider[[L_choice]][i]
    R_name <- df_wider[[R_choice]][i]
    # 得到左右选项的名字后, 基于该名字找到对应的价值.(刺激名被长转宽成了列名)
    df_wider$L_value[i] <- df_wider[[L_name]][i]
    df_wider$R_value[i] <- df_wider[[R_name]][i]
    
################################ [ CORE CODE ] #################################
    # 基于prob函数计算选择左边和右边的概率
    df_wider$L_prob[i] <- prob_func(
      L_value = df_wider$L_value[i],
      R_value = df_wider$R_value[i],
      LR = "L", 
      tau = tau,
      params = params
    )
    df_wider$R_prob[i] <- prob_func(
      L_value = df_wider$L_value[i],
      R_value = df_wider$R_value[i],
      LR = "R", 
      tau = tau,
      params = params
    )
################################ [ CORE CODE ] #################################
 
################################ [ soft-max ] ##################################    
    # 如果是softmax就基于概率随机选
    if (!(softmax %in% c(TRUE, FALSE))) {
      stop("softmax TRUE or FALSE?")
    }
    else if (softmax == TRUE) {
      if (!is.numeric(df_wider$L_value[i]) | !is.numeric(df_wider$R_value[i])) {
        stop("An error occurs when softmax == FALSE")
      }
      # 设置随机种子
      set.seed(seed = seed)
      # 基于刚刚的概率, 随机选一个. 而不是谁大选谁
      df_wider$Rob_Choose[i] <- sample(
        c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), 
        prob = c(df_wider$L_prob[i], df_wider$R_prob[i]),
        size = 1
      ) 
    } 
    # 如果不基于softmax, 就是谁大选谁
    else if (softmax == FALSE) {
      if (!is.numeric(df_wider$L_value[i]) | !is.numeric(df_wider$R_value[i])) {
        stop("An error occurs when softmax == FALSE")
      }
      # 如果左边大选左边
      else if (df_wider$L_value[i] > df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- df_wider[[L_choice]][i]
      } 
      # 如果左边小于右边
      else if (df_wider$L_value[i] < df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- df_wider[[R_choice]][i]
      } 
      # 一样大随机选一个(说明是DS情况), 或者极端情况[L == R]
      else if (df_wider$L_value[i] == df_wider$R_value[i]) {
        df_wider$Rob_Choose[i] <- sample(
          c(df_wider[[L_choice]][i], df_wider[[R_choice]][i]), 
          size = 1
        )
      } 
    }
################################ [ direction ] #################################
    # 如果选项即等于左也等于右, 则说明此时只有一个选项
    if (df_wider$Sub_Choose[i] == L_name & df_wider$Sub_Choose[i] == R_name) {
      df_wider$L_dir[i] <- 0
      df_wider$R_dir[i] <- 0
    } 
    # 选了左
    else if (df_wider$Sub_Choose[i] == L_name & df_wider$Sub_Choose[i] != R_name){
      df_wider$L_dir[i] <- 1
      df_wider$R_dir[i] <- 0
    }
    # 选了右
    else if (df_wider$Sub_Choose[i] != L_name & df_wider$Sub_Choose[i] == R_name){
      df_wider$L_dir[i] <- 0
      df_wider$R_dir[i] <- 1
    }
    else {
      print("L/R_dir ERROR")
    }
    
############################## [ log_likelyhood ] ##############################    
    # 基于得到的被试选项与强化学习估计的选择概率, 计算似然值
    df_wider$L_logl[i] <- df_wider$L_dir[i] * log(df_wider$L_prob[i] + 1e-10)
    df_wider$R_logl[i] <- df_wider$R_dir[i] * log(df_wider$R_prob[i] + 1e-10)
    
################################ [ accuracy ] ##################################
    if (!(df_wider$Rob_Choose[i] %in% choose_col)) {
      stop("ERROR in ACC")
    }
    # 如果被试和强化学习选择一致, 则是1, 不一致则是0
    else if (df_wider$Sub_Choose[i] == df_wider$Rob_Choose[i]) {
      df_wider$ACC[i] <- 1
    }
    else if (df_wider$Sub_Choose[i] != df_wider$Rob_Choose[i]) {
      df_wider$ACC[i] <- 0
    }
  }

################################# [ ROUNND ] ###################################  
  df_wider$L_prob <- round(df_wider$L_prob, 2)
  df_wider$R_prob <- round(df_wider$R_prob, 2)
  df_wider$L_logl <- round(df_wider$L_logl, 2)
  df_wider$R_logl <- round(df_wider$R_logl, 2)
  
  return(df_wider)
}
```

```{r}
test <- rl_action_c(
  data = step1 %>% dplyr::filter(Subject == 1),
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  # column choose
  choose = "Choose",
  # column value
  value = "V_value",
  # 初始值
  initial_value = 0,
  seed = 123,
  softmax = TRUE,
  tau = 1,
  params = NA,
  prob_func = ex_func_prob
)
```

```{r loop_evaluate}
loop_action_c <- function(
  # update_v数据集
  data,
  # 左右选项列名
  L_choice = "DL",
  R_choice = "DR",
  # 被试序号列, 列名
  sub = "Subject",
  # 被试选择刺激列, 列名
  choose = "Choose",
  # 被试当前心中价值, 列名. 默认为"V_value"
  value = "V_value",
  # 表示时间线的列, 便于排序. 可以不止两列
  time_line = c("Block", "Trial"),
  # 初始值
  initial_value = 0,
  # 由update_v函数得到的结果里, 需要跑几个被试的action_c, 默认为1
  n = 1,
  # softmax选择时的随机种子
  seed = 123,
  # 是否使用softmax, 还是说value谁大选谁
  softmax = TRUE,
  # softmax的固有参数, 默认为1
  tau = 1,
  # 如果你的softmax含有别的参数, 就放在这里
  params = NA,
  # 示例softmax函数
  prob_func = ex_func_prob
################################# [function start] #############################
) {
################################# [split sub data] #############################  
  df_split <- base::split(x = data, f = data[[sub]])
  df_res <- list()
  
  for (i in n) {
    df_subject <- df_split[[i]]
################################ [ CORE CODE ] #################################
    df_res[[i]] <- rl_action_c(
      data = df_subject, 
      L_choice = L_choice,
      R_choice = R_choice,
      choose = choose,
      value = value,
      initial_value = initial_value,
      seed = seed,
      softmax = softmax,
      tau = tau,
      params = params,
      prob_func = prob_func
    )
  }
################################ [ CORE CODE ] #################################  
  # 把所有被试的结果合并, 成为总结果
  temp_res <- dplyr::bind_rows(df_res) 
  
################################### [result] ###################################
  # 此时排序基于sub和time_line
  order_var <- c(sub, time_line)
  # 基于time_line这个向量, 录入排序向量
  order_vector <- lapply(order_var, function(col) temp_res[[col]])
  # 基于排序向量对输入数据集进行排序
  res <- temp_res[do.call(order, order_vector), ]
  
  return(res)
}
```

```{r}
step2 <- loop_action_c(
  # update_v数据集
  data = step1,
  # 左右选项
  L_choice = "DL",
  R_choice = "DR",
  sub = "Subject",
  choose = "Choose",
  value = "V_value",
  time_line = c("Block", "Trial"),
  # 初始值
  n = 1:41,
  initial_value = 0,
  seed = 123,
  softmax = FALSE,
  tau = 1,
  params = NA,
  prob_func = ex_func_prob  
)
```

